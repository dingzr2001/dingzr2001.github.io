<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Algorithm - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Algorithm</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-08-20T17:50:00.000Z" title="8/20/2024, 1:50:00 PM">2024-08-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.152Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">2 minutes read (About 257 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/20/lc_141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">&lt;数据结构/算法&gt; leetcode hot100系列. 141(142). 环形链表</a></p><div class="content"><h1 id="LeetCode-hot-100-141-142-环形链表"><a href="#LeetCode-hot-100-141-142-环形链表" class="headerlink" title="[LeetCode hot 100] 141(142). 环形链表"></a>[LeetCode hot 100] 141(142). 环形链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>环形链表的判断在要求空间复杂度为O(1)时，需要使用Floyd判圈法来判断是否存在环。Floyd判圈法的具体讲解<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_61350148/article/details/139557492">看这里</a>。</p>
<p>具体步骤为：</p>
<ol>
<li>快指针fast和慢指针slow指向链表头（首元结点）</li>
<li>fast每次移动两步，slow每次移动一步</li>
<li>如果遇到null说明没有环，如果fast和slow相遇说明有环，进入4</li>
<li>其中一个指针移回链表头，另一个不动</li>
<li>两个指针每次移动一步，直到相遇，就是环的入口</li>
</ol>
<p>完整代码如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-08-20T17:50:00.000Z" title="8/20/2024, 1:50:00 PM">2024-08-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.153Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">3 minutes read (About 501 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/20/lc_23_%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/">&lt;数据结构/算法&gt; leetcode hot100系列. 23. 合并k个升序链表</a></p><div class="content"><h1 id="LeetCode-hot-100-23-合并k个升序链表"><a href="#LeetCode-hot-100-23-合并k个升序链表" class="headerlink" title="[LeetCode hot 100] 23. 合并k个升序链表"></a>[LeetCode hot 100] 23. 合并k个升序链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>如果是合并两个链表那没得说，两个指针分别指向两个链表，每次把小的那个后移。</p>
<p>但是这里是k个，如果用k个指针，每次移动最小的，那么每次都需要遍历一遍找到最小的那个，时间复杂度太高了。</p>
<p>从k个里面找最小，这个情景很适合使用【堆】这种结构。关于堆的知识点<a href="./%E6%88%91%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AD%A6%E4%BC%9A%5B%E5%A0%86%5D.md">传送门</a></p>
<p>这里使用小根堆，因为每次要获得最小的，那么小根堆取堆顶就能很轻松地完成这个工作。堆顶是一个指针，指向某个链表的遍历位置，当取了堆顶之后，需要将遍历指针向后移动一位，并且重新加入到堆中，这里就是把堆顶替换掉，然后<strong>向下调整</strong>，最为方便。</p>
<p>下面是完整代码，其中我偷了点懒，建堆就直接用排序代替了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjustDown</span><span class="params">(vector&lt;ListNode*&gt;&amp; heap)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> parent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * parent + <span class="number">1</span> &lt; heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> lchild = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> minChild = lchild;</span><br><span class="line">            <span class="keyword">if</span>(lchild + <span class="number">1</span> &lt; heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> rchild = lchild + <span class="number">1</span>;</span><br><span class="line">                minChild = heap[lchild]-&gt;val &lt; heap[rchild]-&gt;val ? lchild : rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(heap[parent]-&gt;val &lt; heap[minChild]-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(heap[parent], heap[minChild]);</span><br><span class="line">            parent = minChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">headPop</span><span class="params">(vector&lt;ListNode*&gt;&amp; heap)</span></span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[<span class="number">0</span>], heap[heap.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">adjustDown</span>(heap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; head : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head) heap.<span class="built_in">push_back</span>(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里用排序实现了建堆，效果是一样的</span></span><br><span class="line">        <span class="built_in">sort</span>(heap.<span class="built_in">begin</span>(), heap.<span class="built_in">end</span>(), [](ListNode* a, ListNode* b)&#123;<span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;&#125;);</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* cur = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span>(heap.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(heap[<span class="number">0</span>]-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(heap[<span class="number">0</span>]-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="built_in">headPop</span>(heap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heap[<span class="number">0</span>] = heap[<span class="number">0</span>]-&gt;next;</span><br><span class="line">                <span class="built_in">adjustDown</span>(heap);</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;heap.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自己独立写出来了，有点子感动。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-08-20T17:50:00.000Z" title="8/20/2024, 1:50:00 PM">2024-08-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.153Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">6 minutes read (About 917 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/20/lc_42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/">&lt;数据结构/算法&gt; leetcode hot100系列. 42. 接雨水</a></p><div class="content"><h1 id="LeetCode-hot-100-42-接雨水"><a href="#LeetCode-hot-100-42-接雨水" class="headerlink" title="[LeetCode hot 100] 42. 接雨水"></a>[LeetCode hot 100] 42. 接雨水</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>这个题实在是太经典了，存在感太强了，我认为也是很考验思维的一个题，关键在于要想明白“接水”到底是怎么一回事。</p>
<p>这个题的难点在于，大的容器里可能有小的容器，大坑套小坑，既不能漏算也不能重复算。</p>
<p><img src="D:\dingblog\source\img\leetcode\LC_42.png"></p>
<p>这是一个坑，坑里还有小坑，还有阶梯，应该怎么算这个坑能接多少水呢？我们注意到，任何一个坑都有三个组成部分：左壁，右壁，以及中间的底。为了避免重算，我们把坑分成几层。就像上面这个图一样。我们需要记录左壁的结构，这样才能在碰到右壁时找到对应的左壁进行计算。那么左边的柱子需要全部记录下来吗？其实并不是的。观察上面这个图，当来到第四根柱子时，左边已经产生了一个小坑，这个时候就可以计算这个小坑的面积，然后后面就不需要再计算这个小坑的面积，而是从左右壁比较高的一个往上继续算。</p>
<p>这种结构很适合用<strong>单调栈</strong>来解决，单调栈从栈底到栈顶保持递减，这样可以保证我们栈里留得都是可能作为“壁”的柱子，像图中第3根那种柱子，在碰到第四根更高的柱子，就变成了一个“坑底”，在后续的计算中就不应再考虑，因为他既不影响后面的计算结果（因为自己这个坑已经算过了，更大的坑就要从现在这个坑壁往上算了），也不可能作为后面的坑壁。因此，单调栈维护的过程就是在识别坑，并且算完后把坑底扔掉。对于图中这个情形，过程是：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>操作</th>
<th>栈</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1号入栈</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2比栈顶矮，2入栈</td>
<td>1,2</td>
<td>2可能作为子坑的壁</td>
</tr>
<tr>
<td>3</td>
<td>3比栈顶矮，3入栈</td>
<td>1,2,3</td>
<td>3也可能作为子坑的壁</td>
</tr>
<tr>
<td>4</td>
<td>4比栈顶高，出栈，同时计算4和2（新栈顶）之间的容积</td>
<td>1,2</td>
<td>对应图中青绿色面积</td>
</tr>
<tr>
<td>5</td>
<td>4比栈顶矮，4入栈</td>
<td>1,2,4</td>
<td>4可能作为坑壁</td>
</tr>
<tr>
<td>6</td>
<td>5比栈顶矮，5入栈</td>
<td>1,2,4,5</td>
<td>同上</td>
</tr>
<tr>
<td>7</td>
<td>6比栈顶高，出栈，同时计算6和2（新栈顶）之间的容积</td>
<td>1,2,4</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>6比栈顶矮，入栈</td>
<td>1,2,4,6</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>7比栈顶高，出栈，同时计算7和4（新栈顶）之间的容积</td>
<td>1,2,4</td>
<td>对应图中浅紫色面积</td>
</tr>
<tr>
<td>10</td>
<td>7比栈顶高，出栈，同时计算7和2（新栈顶）之间的容积</td>
<td>1,2</td>
<td>对应紫色面积</td>
</tr>
<tr>
<td>11</td>
<td>7比栈顶高，出栈，同时计算7和1（新栈顶）之间的容积</td>
<td>1</td>
<td>对应深蓝色面积</td>
</tr>
<tr>
<td>12</td>
<td>7比栈顶矮，7入栈</td>
<td>1,7</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>遍历结束</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>结合图来看就可以理解了，其实这个问题想成<strong>填水泥</strong>更好，小坑里面填完了水泥，大坑再填就不用填小坑了，从小坑上面接着填就行，就是这个道理。</p>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> bottom = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line">                ans += (i - left - <span class="number">1</span>) * (<span class="built_in">min</span>(height[left], height[i]) - height[bottom]);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-08-20T17:50:00.000Z" title="8/20/2024, 1:50:00 PM">2024-08-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.153Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">3 minutes read (About 521 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/08/20/lc_48_%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/">&lt;数据结构/算法&gt; leetcode hot100系列. 48. 旋转图像</a></p><div class="content"><h1 id="LeetCode-hot-100-48-旋转图像"><a href="#LeetCode-hot-100-48-旋转图像" class="headerlink" title="[LeetCode hot 100] 48. 旋转图像"></a>[LeetCode hot 100] 48. 旋转图像</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<h3 id="解法1：按圈旋转"><a href="#解法1：按圈旋转" class="headerlink" title="解法1：按圈旋转"></a>解法1：按圈旋转</h3><p>这个题做的时候真是折磨，做的时候就想到像轮转数组那样可以通过多次翻转来实现旋转矩阵的效果，不过一想，好像可以一圈一圈转，也可以实现O(1)空间复杂度。具体是怎样转的呢？我画了一个图：</p>
<p><img src="D:\dingblog\source\img\leetcode\lc_48.png"></p>
<p>对于某一个环，可以分为上、右、下、左四条，旋转时上边转到右边，右边转到下边，下边转到左边，左边转到上边。如果以边为单位转，需要一个O(N)大小的数组来保存。想要O(1)空间复杂度可以一个一个转，只需要弄明白四条边上对应位置的关系。</p>
<p>我们首先用一层循环来遍历旋转的圈。假如我们在从外到内第$i$个圈，$0&lt;i&lt;n&#x2F;2$（如果n是奇数也对，因为最内圈就一个元素不用转）。</p>
<p>然后用第二层循环来遍历当前轮转的是元素。假如我们在对第$j$个元素进行轮转，$0&lt;j&lt;n-2i-1$，注意为什么要减1，是因为每条边不能包含最后一个元素，否则就多转了一次。</p>
<ul>
<li>上边的元素位置是：$(i,i+j)$</li>
<li>右边的元素位置是：$(i+j,n-1-i)$</li>
<li>下边的元素位置是：$(n-1-i,n-1-i-j)$</li>
<li>左边的元素位置是：$(n-1-i-j,i)$</li>
</ul>
<p>所以要做的就是先把左边的元素保存一下，然后把下边放到左边，右边放到下边，上边放到右边，最后把保存的左边元素放到上边。</p>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">2</span> * i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = matrix[n<span class="number">-1</span>-i-j][i];</span><br><span class="line">                matrix[n<span class="number">-1</span>-i-j][i] = matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-i-j];</span><br><span class="line">                matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-i-j] = matrix[i+j][n<span class="number">-1</span>-i];</span><br><span class="line">                matrix[i+j][n<span class="number">-1</span>-i] = matrix[i][i+j];</span><br><span class="line">                matrix[i][i+j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法2：翻转实现旋转"><a href="#解法2：翻转实现旋转" class="headerlink" title="解法2：翻转实现旋转"></a>解法2：翻转实现旋转</h3><p>后来看题解确实是可以用翻转实现旋转的。方法是首先对矩阵进行上下翻转，然后进行主对角线翻转，就完成了！</p>
<p>只需要注意主对角线两侧对称的元素关系是$matrix[i][j]$和$matrix[j][i]$，即一维下标和二维下标互换。并且上三角元素$matrix[i][j]$的下标范围是$i\leq j$，而下三角元素的下标范围是$j\leq i$</p>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n<span class="number">-1</span>-i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-28T17:50:00.000Z" title="7/28/2024, 1:50:00 PM">2024-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.152Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">4 minutes read (About 525 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/28/lc_105_%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">&lt;数据结构/算法&gt; leetcode hot100系列. 105. 从前序与中序遍历序列构造二叉树</a></p><div class="content"><h1 id="LeetCode-hot-100-105-从前序与中序遍历序列构造二叉树"><a href="#LeetCode-hot-100-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="[LeetCode hot 100] 105. 从前序与中序遍历序列构造二叉树"></a>[LeetCode hot 100] 105. 从前序与中序遍历序列构造二叉树</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>这个题的关键是理解前序遍历的序列是：【根节点，【左子树】，【右子树】】，而中序遍历的序列是【【左子树】，根节点，【右子树】】。当我们拿到一个前序遍历的序列，唯一能确定的就是第一个数一定是根节点。拿到根节点后，由于没有重复值，所以可以确定中序遍历序列中根节点的位置，从而得到中序遍历的左子树区间和右子树区间，并且得到这两个区间的长度，这样前序遍历的左子树区间和右子树区间也可以确定了。进而，左孩子节点和右孩子节点就可以确定了。</p>
<p>如果我们只看前序和中序的左子树的区间，就可以再得到左子树的左右孩子，以此类推，所以这是一个递归的过程，递归的参数只需要加上两个序列的起止点，来圈定当前子树的区间。</p>
<p>特别地，可以使用哈希表来存放每个值在中序遍历序列中的位置，这样就不用每次都用O(n)或O(logn)的时间查一遍了。</p>
<p>完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inorderMap;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preEnd &lt; preStart) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rootVal = preorder[preStart];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> inRootPos = inorderMap[rootVal];</span><br><span class="line">        <span class="type">int</span> leftSize = inRootPos - inStart;</span><br><span class="line">        TreeNode* left = <span class="built_in">recur</span>(preorder, inorder, preStart + <span class="number">1</span>, preStart + leftSize, inStart, inRootPos - <span class="number">1</span>);</span><br><span class="line">        TreeNode* right = <span class="built_in">recur</span>(preorder, inorder, preStart + leftSize + <span class="number">1</span>, preEnd, inRootPos + <span class="number">1</span>, inEnd);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal, left, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            inorderMap[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(preorder, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-28T17:50:00.000Z" title="7/28/2024, 1:50:00 PM">2024-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.152Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">3 minutes read (About 499 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/28/lc_114_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/">&lt;数据结构/算法&gt; leetcode hot100系列. 114. 二叉树展开为链表</a></p><div class="content"><h1 id="LeetCode-hot-100-128-将有序数组转化为二叉搜索树"><a href="#LeetCode-hot-100-128-将有序数组转化为二叉搜索树" class="headerlink" title="[LeetCode hot 100] 128. 将有序数组转化为二叉搜索树"></a>[LeetCode hot 100] 128. 将有序数组转化为二叉搜索树</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>这个题有点意思，乍一看挺简单，想一下就会发现有点点坑。</p>
<p>展开的结果是先序遍历的顺序，也就是说对于某个节点，展开后它的右子树这一串应该是根节点→左子树→右子树这个顺序，而左子树和右子树也是这样展开的。</p>
<p>所以对一个节点，我们首先要将左子树链到右子树中，再对左右子树都执行这个操作。这个过程的实现方法叫做Morris遍历，方法是找到左子树的最右节点，再将右子树接到该节点的下面。这玩意的正确性我不会证明，但是可以画一条$y&#x3D;-x$的斜线，这个过程就相当于沿着这个方向一层一层剥开。知乎上找到一个挺好的示意图</p>
<p><img src="D:\dingblog\source\img\leetcode\144_morris.jpg"></p>
<p>每次把左子树连到右子树之后，需要再对左子树内也进行同样的操作，但是此时左子树就是我们根节点的右孩子，因此把指针移动到右孩子，重复这个循环。此外，右子树也需要执行这个操作，同样不用担心，指针一直往右移动，早晚会指向原本的右子树的根节点，也就是原来的右孩子。代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            TreeNode* leftRight = cur-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(leftRight)&#123;</span><br><span class="line">                <span class="keyword">while</span>(leftRight-&gt;right)&#123;</span><br><span class="line">                    leftRight = leftRight-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                leftRight-&gt;right = cur-&gt;right;</span><br><span class="line">                cur-&gt;right = cur-&gt;left;</span><br><span class="line">                cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-28T17:50:00.000Z" title="7/28/2024, 1:50:00 PM">2024-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.152Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">3 minutes read (About 375 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/28/lc_128_%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">&lt;数据结构/算法&gt; leetcode hot100系列. 128. 将有序数组转化为二叉搜索树</a></p><div class="content"><h1 id="LeetCode-hot-100-128-将有序数组转化为二叉搜索树"><a href="#LeetCode-hot-100-128-将有序数组转化为二叉搜索树" class="headerlink" title="[LeetCode hot 100] 128. 将有序数组转化为二叉搜索树"></a>[LeetCode hot 100] 128. 将有序数组转化为二叉搜索树</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>这个题很自然地想到要用递归，这也是构建二叉搜索树的标准步骤。每次都从当前的区间取中点作为根节点，并且分别在左右半区内寻找左孩子和右孩子（即左右半区的中点），如此递归。唯一需要注意的是我们在每次递归中都在做些什么？答：我们找到当前的节点，并调用递归来构造当前节点的左右孩子节点。只要左右孩子都没有就可以返回了，但是这样判断起来太麻烦，不如直接再往深了走一层，假如当前节点不存在(即left &gt; right)，就说明走到了不存在的孩子那一层，返回null即可，正好方便父节点把对应孩子的指针设为null。</p>
<p>完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">recur</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        cur-&gt;left = <span class="built_in">recur</span>(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        cur-&gt;right = <span class="built_in">recur</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-28T17:50:00.000Z" title="7/28/2024, 1:50:00 PM">2024-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.152Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">3 minutes read (About 524 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/28/lc_146_LRU%E7%BC%93%E5%AD%98/">&lt;数据结构/算法&gt; leetcode hot100系列. 146. LRU缓存</a></p><div class="content"><h1 id="LeetCode-hot-100-146-LRU缓存"><a href="#LeetCode-hot-100-146-LRU缓存" class="headerlink" title="[LeetCode hot 100] 146. LRU缓存"></a>[LeetCode hot 100] 146. LRU缓存</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>也是高频题目了，为了使查询get达到O(1)，自然是用哈希表来存储，但是又需要在O(1)时间完成删除（即逐出）、调整顺序等操作。这里使用<strong>双向链表</strong>比较合适，主要是因为比较方便删除。传统的单向链表想要删除还需要再遍历一遍获取前驱节点，而双向链表自带前驱节点，可以不用遍历就直接删除。</p>
<p>将二者结合，则哈希表应该保存&lt;key, 链表节点&gt;这样的键值对，这样可以通过key直接找到对应的节点，方便移位。</p>
<p>另外为了实现放到头部和删除尾部元素这两个操作，需要建立头结点和尾节点，注意不是头指针和尾指针，而是单独的头节点和尾节点。</p>
<p>完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BiListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    BiListNode* prev;</span><br><span class="line">    BiListNode* next;</span><br><span class="line">    <span class="built_in">BiListNode</span>(<span class="type">int</span> key, <span class="type">int</span> value):<span class="built_in">key</span>(key), <span class="built_in">value</span>(value)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BiListNode* head;</span><br><span class="line">    BiListNode* tail;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> usage;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, BiListNode*&gt; keyMap;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="keyword">new</span> <span class="built_in">BiListNode</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;tail = <span class="keyword">new</span> <span class="built_in">BiListNode</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">        head-&gt;prev = tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;usage = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!keyMap.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        BiListNode* entry = keyMap[key];</span><br><span class="line">        <span class="comment">//从原本位置拿走</span></span><br><span class="line">        entry-&gt;prev-&gt;next = entry-&gt;next;</span><br><span class="line">        entry-&gt;next-&gt;prev = entry-&gt;prev;    </span><br><span class="line">        head-&gt;next-&gt;prev = entry;</span><br><span class="line">        <span class="comment">//放到头部</span></span><br><span class="line">        entry-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = entry;</span><br><span class="line">        entry-&gt;prev = head;</span><br><span class="line">        <span class="keyword">return</span> entry-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!keyMap.<span class="built_in">count</span>(key))&#123;</span><br><span class="line">            <span class="keyword">if</span>(usage &gt;= capacity)&#123;</span><br><span class="line">                <span class="comment">//删除尾部元素，注意在哈希表里也要删除</span></span><br><span class="line">                BiListNode* tmp = tail-&gt;prev;</span><br><span class="line">                keyMap.<span class="built_in">erase</span>(tmp-&gt;key);</span><br><span class="line">                tail-&gt;prev-&gt;prev-&gt;next = tail;</span><br><span class="line">                tail-&gt;prev = tmp-&gt;prev;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">                usage--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在头部插入新元素</span></span><br><span class="line">            BiListNode* entry = <span class="keyword">new</span> <span class="built_in">BiListNode</span>(key, value);</span><br><span class="line">            entry-&gt;next = head-&gt;next;</span><br><span class="line">            entry-&gt;prev = head;</span><br><span class="line">            entry-&gt;next-&gt;prev = entry;</span><br><span class="line">            head-&gt;next = entry;</span><br><span class="line">            keyMap.<span class="built_in">emplace</span>(key, entry);</span><br><span class="line">            usage++;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            BiListNode* entry = keyMap[key];</span><br><span class="line">            entry-&gt;value = value; <span class="comment">//更新value值</span></span><br><span class="line">            <span class="comment">//放到头部</span></span><br><span class="line">            entry-&gt;prev-&gt;next = entry-&gt;next;</span><br><span class="line">            entry-&gt;next-&gt;prev = entry-&gt;prev;</span><br><span class="line">            entry-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;prev = entry;</span><br><span class="line">            head-&gt;next = entry;</span><br><span class="line">            entry-&gt;prev = head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-28T17:50:00.000Z" title="7/28/2024, 1:50:00 PM">2024-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.152Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">5 minutes read (About 769 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/28/lc_239_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/">&lt;数据结构/算法&gt; leetcode hot100系列. 239.滑动窗口最大值</a></p><div class="content"><h1 id="LeetCode-hot-100-239-滑动窗口最大值"><a href="#LeetCode-hot-100-239-滑动窗口最大值" class="headerlink" title="[LeetCode hot 100] 239. 滑动窗口最大值"></a>[LeetCode hot 100] 239. 滑动窗口最大值</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>非常有趣的一道题。我们首先思考一下，每次窗口移动可能会发生什么事。</p>
<ol>
<li>假如移出去的那个数不是之前窗口的最大值，那没问题，直接丢掉就可以。</li>
<li>假如移出去的恰好就是窗口的最大值，那么把它移走了，新王登基，怎样又快又准地去找这个新王是谁呢？</li>
</ol>
<p>我们来看第一种情况，如果这个数不是最大值，说明后面一定存在一个数比它更大。当窗口移动时，由于这个数在前面，所以先被卡掉，但是因为后面还有更大的，所以卡掉它对于窗口的最大值不起任何影响。因此这种数对于结果起不到任何的改变，是窗口中的小透明，我们不需要管它们。</p>
<p>那么剩下的另一种数就是窗口的后面没有比它大的了，这种才是我们需要考虑的，因为它们是真正关乎到滑动窗口最大值的数。</p>
<p>我们要记录所有的这种数，这样的单调序列再加上滑动窗口这种每次后面进来一个数，前面出来一个数的结构，非常适合使用单调队列来记录。单调队列中，元素从队头到队尾递减，每次后移一位，就对比新的数和队尾，如果队尾比新数小，就说明队尾是小透明，出队扔掉，再比较新的队尾，也就是本来在队尾的前一位，比队尾大一点，如此循环直到队尾不比新数小，也就是踢到了钢板。这时将新数入队。</p>
<p>同时，移动窗口会导致原来窗口中的第一位被卡掉，这时如果被卡掉的正好是队头，那说明它恰好是最大的那个，就需要从队头把它出队。（由于可能有重复值，因此队列中需要存储下标，通过下标进行比对）</p>
<p>每个窗口中最大的元素一定就是当前的队头。</p>
<p>综合以上，完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//首先建立第一个窗口的优先队列，后续的优先队列都在此基础上调整</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">                    cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">if</span>(dq.<span class="built_in">empty</span>() || nums[dq.<span class="built_in">back</span>()] &gt;= nums[j])&#123;</span><br><span class="line">                        dq.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[j])&#123;</span><br><span class="line">                            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                        dq.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == i - <span class="number">1</span>)&#123;</span><br><span class="line">                    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dq.<span class="built_in">empty</span>() || nums[dq.<span class="built_in">back</span>()] &gt;= nums[i+k<span class="number">-1</span>])&#123;</span><br><span class="line">                    dq.<span class="built_in">push_back</span>(i+k<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i+k<span class="number">-1</span>])&#123;</span><br><span class="line">                        dq.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    dq.<span class="built_in">push_back</span>(i+k<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-07-28T17:50:00.000Z" title="7/28/2024, 1:50:00 PM">2024-07-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-09-06T17:08:12.153Z" title="9/6/2025, 1:08:12 PM">2025-09-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/">C++</a><span> / </span><a class="link-muted" href="/categories/Algorithm/C/job/">job</a></span><span class="level-item">4 minutes read (About 656 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/07/28/lc_25_k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/">&lt;数据结构/算法&gt; leetcode hot100系列. 25. k个一组翻转链表</a></p><div class="content"><h1 id="LeetCode-hot-100-25-k个一组翻转链表"><a href="#LeetCode-hot-100-25-k个一组翻转链表" class="headerlink" title="[LeetCode hot 100] 25. k个一组翻转链表"></a>[LeetCode hot 100] 25. k个一组翻转链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked">题目链接</a></p>
<p>好折磨的题，要想明白还真是得费一些脑筋。</p>
<p>我们已经做过<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">LeetCode 206 反转链表</a>，直到反转链表的思路是保留一个前驱节点，然后每次让后继结点的next指向前驱节点。这个题中对于每一组中的反转自然也可以这样做。</p>
<p>不过难点就在于局部反转后怎样和原链表接起来。思路我大致画了个图（假设k&#x3D;2）：</p>
<p><img src="D:\dingblog\source\img\leetcode\lc_25.png"></p>
<p>这里有个很tricky的点，就是这个prev的设置。由于我们需要确定一组k个节点中的最后一个，所以需要使用快慢指针，快指针比慢指针领先k，并且二者每轮同时后移k个。慢指针是当前k个的前一个，也就是next指向当前k个中第一个的节点，而快指针就是当前k个的最后一个。在反转整个链表时，我们首先令prev&#x3D;nullptr，这是因为原先的第一个节点会变成最后一个，而最后一个节点的next指向的就是null。但是这里不同，我们每一组的第一个节点变成最后一个节点后，还需要指向下一组的头，所以prev在每组开始反转的时候都应该先指向下一组的头，那么这个下一组的头就是fast-&gt;next。</p>
<p>每组反转之后，这一组的尾就已经接在下一组的头上了，但是注意，每一组的头都会变的，所以在遍历之后应该让上一组的尾重新指向这个新的头。新的头就是反转结束后prev的位置，而上一组的尾就是slow，所以需要slow-&gt;next &#x3D; prev;</p>
<p>挺绕的，还是看图好懂一点吧~</p>
<p>完整代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode* fast = &amp;dummy;</span><br><span class="line">        ListNode* slow = fast;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!fast-&gt;next) <span class="keyword">return</span> dummy.next;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* prev = fast-&gt;next;</span><br><span class="line">            ListNode* cur = slow-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(prev != fast)&#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = prev;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cout&lt;&lt;cur-&gt;val&lt;&lt;endl;</span><br><span class="line">                cur = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ListNode* newEnd = slow-&gt;next;</span><br><span class="line">            newEnd-&gt;next = cur;</span><br><span class="line">            slow-&gt;next = fast;</span><br><span class="line">            slow = fast = newEnd;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Algorithm/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/Algorithm/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Algorithm/">1</a></li><li><a class="pagination-link" href="/categories/Algorithm/page/2/">2</a></li><li><a class="pagination-link" href="/categories/Algorithm/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">36</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">28</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">22</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">22</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/C/job/"><span class="level-start"><span class="level-item">job</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Programming-Language/"><span class="level-start"><span class="level-item">Programming Language</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming-Language/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/db-index/"><span class="level-start"><span class="level-item">db_index</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/db-index/predictive/"><span class="level-start"><span class="level-item">predictive</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/machine-learning/"><span class="level-start"><span class="level-item">machine learning</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/machine-learning/Dive-into-Deep-Learning-Notes/"><span class="level-start"><span class="level-item">Dive into Deep Learning-Notes</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/machine-learning/Dive-into-Deep-Learning-Notes/optimization/"><span class="level-start"><span class="level-item">optimization</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/mlsys/"><span class="level-start"><span class="level-item">mlsys</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/python/basics/"><span class="level-start"><span class="level-item">basics</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/ubuntu/"><span class="level-start"><span class="level-item">ubuntu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vector-db/"><span class="level-start"><span class="level-item">vector_db</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-06T17:08:12.153Z">2025-09-06</time></p><p class="title"><a href="/2025/09/06/%E4%BD%BF%E7%94%A8vue%E5%92%8Celementui%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-06T17:08:12.152Z">2025-09-06</time></p><p class="title"><a href="/2025/09/06/hello-world/">Hello World</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-06T17:08:12.150Z">2025-09-06</time></p><p class="title"><a href="/2025/09/06/CNN%20Convolution/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-06T17:08:12.150Z">2025-09-06</time></p><p class="title"><a href="/2025/09/06/MySQL%E4%B8%80%E4%BA%9B%E5%BA%95%E5%B1%82%E7%9A%84%E4%B8%9C%E8%A5%BF/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-08-20T17:50:00.000Z">2024-08-20</time></p><p class="title"><a href="/2024/08/20/lc_141_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">&lt;数据结构/算法&gt; leetcode hot100系列. 141(142). 环形链表</a></p><p class="categories"><a href="/categories/Algorithm/">Algorithm</a> / <a href="/categories/Algorithm/C/">C++</a> / <a href="/categories/Algorithm/C/job/">job</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/09/"><span class="level-start"><span class="level-item">September 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">August 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/07/"><span class="level-start"><span class="level-item">July 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">January 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/STL/"><span class="tag">STL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/backtrack/"><span class="tag">backtrack</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/binary-tree/"><span class="tag">binary-tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/copy/"><span class="tag">copy</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpu-gpu-co-design/"><span class="tag">cpu-gpu co-design</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/database/"><span class="tag">database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/distributed-system/"><span class="tag">distributed system</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/distribution-shift/"><span class="tag">distribution shift</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dp/"><span class="tag">dp</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/greenplum/"><span class="tag">greenplum</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hash/"><span class="tag">hash</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/heap/"><span class="tag">heap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/index/"><span class="tag">index</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/machine-learning/"><span class="tag">machine learning</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mlsys/"><span class="tag">mlsys</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/optimization/"><span class="tag">optimization</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postgresql/"><span class="tag">postgresql</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/predict/"><span class="tag">predict</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python37/"><span class="tag">python37</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slide-window/"><span class="tag">slide-window</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sort/"><span class="tag">sort</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/two-pointers/"><span class="tag">two-pointers</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/variable/"><span class="tag">variable</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vector-database/"><span class="tag">vector database</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2025 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>